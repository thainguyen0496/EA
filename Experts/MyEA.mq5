//+------------------------------------------------------------------+
//| EA_MultiStrategy_PineParity_v1.mq5                               |
//| Prototype: Multi-strategy EA (Trend/Mean) based on Pine logic    |
//| - Implements 5 logics: Trend XAU, Trend UJ, Mean XAU, Mean UJ,   |
//|   Mean AUDJ                                                       |
//| - Mode switching via ADX (Trend priority)                        |
//| - Risk-by-Vi (weights) and riskSplitA (10/90)                    |
//| - Market orders, SL/TP, BB (iBands) and ADX (custom Wilder opt)  |
//|                                                                  |
//| IMPORTANT: This is a working prototype. Test thoroughly in demo. |
//+------------------------------------------------------------------+
#property copyright "Generated by Copilot"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

//--- INPUTS (global)
input int    ServerUTCOffsetHours = 0;     // Server offset from UTC (hours)
input bool   UseCustomWilder = true;       // Use custom Wilder RMA for ADX
input int    MaxTotalSetupsOpen = 3;
input int    MaxPerSymbol = 1;
input double DailyLossCapPct = 2.0;        // percent of equity -> stop trading
input ENUM_TIMEFRAMES IndTimeframe = PERIOD_M3; // timeframe to evaluate (M3)
input double riskPctDefault = 0.5;         // percent of Vi per setup (default)
input double riskSplitA = 0.1;             // leg A fraction (10%)
input double MinSpreadPoints = 1.0;        // max allowed spread in points (guard)
input double MaxSlippagePoints = 5.0;      // slippage allowed in points
input int    RebalanceMode = 0;            // 0=Continuous (each trade),1=Daily,2=Monthly
input int    MaxADXLookback = 50;          // safe buffer for ADX calc

//--- Per-strategy symbol & params (you can edit defaults)
struct StratParams {
  string symbol;
  bool   enabled;
  // BB
  int    bb_length;
  double bb_mult;
  double outsidePips;
  double bandPadPips;
  double slBufferPips;
  // ADX
  int    diLen;
  int    adxLen;
  double adxMin;   // for trend
  double adxMax;   // for mean
  bool   requireAdxRising;
  // Trend lookback
  int    lookbackSL;
  // pipSize
  double pipSize;
  // candles
  bool   useBE,useBH,useST,useBullE,useBullH,useEvening,useMorning;
  // breakMode (0=BAND_HL,1=CLOSE_HL)
  int    breakMode;
};

//--- default strategy parameter instances (5)
StratParams sTrendXAU = {"XAUUSD", true, 20, 2.0, 9.0, 7.6, 0.1, 14, 17, 15.8, true, 4, 0.1, true,true,true,true,true,true,false,0};
StratParams sTrendUJ  = {"USDJPY", true, 20, 2.0, 5.0, 50.0, 0.5, 5, 9, 18.0, true, 6, 0.001, true,true,true,true,true,true,false,0};
StratParams sMeanXAU  = {"XAUUSD", true, 20, 2.0, 6.0, 42.0, 0.1, 16, 14, 17.0, false, 0, 0.1, true,true,true,true,true,true,false,0};
StratParams sMeanUJ   = {"USDJPY", true, 20, 2.0, 5.0, 100.0, 0.1, 13, 18, 16.8, false, 0, 0.001, true,true,true,true,true,true,false,0};
StratParams sMeanAUDJ = {"AUDJPY", true, 20, 2.0, 7.0, 88.0, 0.1, 15, 18, 16.8, false, 0, 0.001, true,true,true,true,true,false,false,0};

//--- weights (Vi proportion)
double wTrendXAU = 0.35;
double wTrendUJ  = 0.15;
double wMeanXAU  = 0.10;
double wMeanUJ   = 0.20;
double wMeanAUDJ = 0.20;

//--- magic numbers
int MAGIC_Trend_XAU = 11;
int MAGIC_Mean_XAU  = 12;
int MAGIC_Trend_UJ  = 21;
int MAGIC_Mean_UJ   = 22;
int MAGIC_Mean_AUDJ = 32;

//--- internal state
datetime lastBarTimeSymbol(string symbol);
ulong lastGlobalBar = 0;
double EquityStartOfDay = 0.0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   Print("EA_MultiStrategy_PineParity_v1 init");
   // initialize equity baseline
   EquityStartOfDay = AccountInfoDouble(ACCOUNT_EQUITY);
   EventSetTimer(10); // periodic maintenance (10s)
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinit function                                           |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   EventKillTimer();
  }
//+------------------------------------------------------------------+
//| Timer event (not core)                                           |
//+------------------------------------------------------------------+
void OnTimer()
  {
   // optional: daily reset logic
  }
//+------------------------------------------------------------------+
//| OnTick: main entry                                               |
//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime lastRun=0;
   // only run logic once per new M3 bar (global sync)
   // get current server time in UTC
   datetime serverTime = TimeCurrent() - ServerUTCOffsetHours*3600;
   MqlRates rates[];
   if(CopyRates(Symbol(),IndTimeframe,0,2,rates)<=0) return;
   datetime currentBarTime = rates[0].time;
   if(currentBarTime==lastRun) return;
   lastRun = currentBarTime;

   // check DailyLossCap
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(DailyLossTriggered(equity))
     {
      Print("Daily loss cap reached. No new trades.");
      return;
     }

   // Rebalance Vi per mode when needed (we update Vi on demand before entering trade)
   // Evaluate all symbols' signals to decide MODE
   bool anyTrend=false, anyMean=false;
   // compute signal flags for each symbol
   bool trendX=false, meanX=false, trendU=false, meanU=false, meanA=false;

   trendX = EvaluateTrendSignal(sTrendXAU);
   meanX  = EvaluateMeanSignal(sMeanXAU);
   trendU = EvaluateTrendSignal(sTrendUJ);
   meanU  = EvaluateMeanSignal(sMeanUJ);
   meanA  = EvaluateMeanSignal(sMeanAUDJ);

   anyTrend = trendX || trendU;
   anyMean  = (meanX || meanU || meanA);

   // Mode switching per spec: Trend priority
   if(anyTrend)
     {
      // MODE_TREND: process trend symbols (XAU, UJ)
      ProcessModeTrend(trendX, trendU);
     }
   else if(anyMean)
     {
      // MODE_MEAN: process mean symbols (XAU, UJ, AUDJ)
      ProcessModeMean(meanX, meanU, meanA);
     }
   else
     {
      // MODE_IDLE: nothing to do
     }
  }

//+------------------------------------------------------------------+
//| Helpers: Daily loss cap                                           |
//+------------------------------------------------------------------+
bool DailyLossTriggered(double equity)
  {
   static double equityAtDayStart = -1;
   datetime serverUTC = TimeCurrent() - ServerUTCOffsetHours*3600;
   MqlDateTime dt; TimeToStruct(serverUTC,dt);
   if(equityAtDayStart<0 || dt.hour==0 && dt.min==0) equityAtDayStart = EquityStartOfDay = AccountInfoDouble(ACCOUNT_EQUITY);
   double lossPct = 100.0*(equityAtDayStart - equity)/equityAtDayStart;
   if(lossPct >= DailyLossCapPct) return true;
   return false;
  }

//+------------------------------------------------------------------+
//| Mode: Trend processing                                            |
//+------------------------------------------------------------------+
void ProcessModeTrend(bool trendX, bool trendU)
  {
   // allow both XAU and UJ trend (if both signals true)
   int openSetups = CountOpenSetups();
   if(trendX && sTrendXAU.enabled)
     {
      if(openSetups < MaxTotalSetupsOpen && !HasOpenSetupForSymbol(sTrendXAU.symbol))
         TryEnterTrend(sTrendXAU, MAGIC_Trend_XAU, wTrendXAU);
     }
   if(trendU && sTrendUJ.enabled)
     {
      openSetups = CountOpenSetups();
      if(openSetups < MaxTotalSetupsOpen && !HasOpenSetupForSymbol(sTrendUJ.symbol))
         TryEnterTrend(sTrendUJ, MAGIC_Trend_UJ, wTrendUJ);
     }
  }

//+------------------------------------------------------------------+
//| Mode: Mean processing                                             |
//+------------------------------------------------------------------+
void ProcessModeMean(bool meanX, bool meanU, bool meanA)
  {
   int openSetups = CountOpenSetups();
   // process Mean XAU
   if(meanX && sMeanXAU.enabled && openSetups < MaxTotalSetupsOpen && !HasOpenSetupForSymbol(sMeanXAU.symbol))
     TryEnterMean(sMeanXAU, MAGIC_Mean_XAU, wMeanXAU);
   openSetups = CountOpenSetups();
   if(meanU && sMeanUJ.enabled && openSetups < MaxTotalSetupsOpen && !HasOpenSetupForSymbol(sMeanUJ.symbol))
     TryEnterMean(sMeanUJ, MAGIC_Mean_UJ, wMeanUJ);
   openSetups = CountOpenSetups();
   if(meanA && sMeanAUDJ.enabled && openSetups < MaxTotalSetupsOpen && !HasOpenSetupForSymbol(sMeanAUDJ.symbol))
     TryEnterMean(sMeanAUDJ, MAGIC_Mean_AUDJ, wMeanAUDJ);
  }

//+------------------------------------------------------------------+
//| Evaluate Trend/Mean signals (wrappers)                           |
//+------------------------------------------------------------------+
bool EvaluateTrendSignal(const StratParams &sp)
  {
   // load last 3 bars of M3
   MqlRates r[];
   if(CopyRates(sp.symbol,IndTimeframe,0,10,r) < sp.bb_length+5) 
     {
      // insufficient bars
      PrintFormat("EvaluateTrendSignal: insufficient bars for %s", sp.symbol);
      return false;
     }
   // compute BB using iBands
   int handle = iBands(sp.symbol,IndTimeframe,sp.bb_length,(int)sp.bb_mult,0,PRICE_CLOSE);
   double upper[], middle[], lower[];
   if(CopyBuffer(handle,0,0,3,upper) < 1) { IndicatorRelease(handle); return false; }
   if(CopyBuffer(handle,1,0,3,middle) < 1) { IndicatorRelease(handle); return false; }
   if(CopyBuffer(handle,2,0,3,lower) < 1) { IndicatorRelease(handle); return false; }
   IndicatorRelease(handle);

   // ADX
   double adx = 0.0;
   if(UseCustomWilder)
      adx = CalcADX_Custom(sp.symbol, sp.diLen, sp.adxLen);
   else
      adx = iADXGet(sp.symbol,IndTimeframe,sp.adxLen); // wrapper below

   // prevOut flags
   MqlRates rates[];
   CopyRates(sp.symbol,IndTimeframe,0,3,rates);
   bool prevOutUpper = rates[1].close > upper[1] + sp.outsidePips * sp.pipSize;
   bool prevOutLower = rates[1].close < lower[1] - sp.outsidePips * sp.pipSize;

   // break conditions (BAND_HL/CLOSE_HL)
   double upperPrev = upper[1];
   double lowerPrev = lower[1];
   bool longBreakBandHL = rates[0].high > upperPrev;
   bool longBreakCloseHL = (rates[0].close > upperPrev) && (rates[0].high > rates[1].high);
   bool shortBreakBandHL = rates[0].low < lowerPrev;
   bool shortBreakCloseHL = (rates[0].close < lowerPrev) && (rates[0].low < rates[1].low);
   bool longBreak = (sp.breakMode==0) ? longBreakBandHL : longBreakCloseHL;
   bool shortBreak = (sp.breakMode==0) ? shortBreakBandHL : shortBreakCloseHL;

   bool adxOK = (adx >= sp.adxMin);
   bool adxRising = true;
   if(sp.requireAdxRising)
     {
      // compute adx[1]
      double adx1 = 0;
      if(UseCustomWilder) adx1 = CalcADX_Custom(sp.symbol, sp.diLen, sp.adxLen, 1);
      else adx1 = iADXGetPrevious(sp.symbol,IndTimeframe,sp.adxLen);
      adxRising = (adx > adx1);
     }

   bool inSession = IsInAsianSession(sp.symbol);
   bool cond = inSession && adxOK && adxRising && ( (prevOutUpper && nowInBandFromAbove(sp.symbol, upper[0])) || (prevOutLower && nowInBandFromBelow(sp.symbol, lower[0])) ) && (longBreak || shortBreak);
   // Simpler: we check prevOut and break; detailed tuning later
   // But return true if either longBreak or shortBreak with prevOut condition
   if(inSession && adxOK && ( (prevOutUpper && nowInBandFromAbove(sp.symbol, upper[0]) && shortBreak) || (prevOutLower && nowInBandFromBelow(sp.symbol, lower[0]) && longBreak) ))
      return true;
   // fallback: if prevOut && break
   if(inSession && adxOK && (prevOutUpper && shortBreak || prevOutLower && longBreak)) return true;
   return false;
  }

bool EvaluateMeanSignal(const StratParams &sp)
  {
   MqlRates r[];
   if(CopyRates(sp.symbol,IndTimeframe,0,10,r) < sp.bb_length+5) 
     {
      PrintFormat("EvaluateMeanSignal: insufficient bars for %s", sp.symbol);
      return false;
     }
   int handle = iBands(sp.symbol,IndTimeframe,sp.bb_length,(int)sp.bb_mult,0,PRICE_CLOSE);
   double upper[], middle[], lower[];
   if(CopyBuffer(handle,0,0,3,upper) < 1) { IndicatorRelease(handle); return false; }
   if(CopyBuffer(handle,1,0,3,middle) < 1) { IndicatorRelease(handle); return false; }
   if(CopyBuffer(handle,2,0,3,lower) < 1) { IndicatorRelease(handle); return false; }
   IndicatorRelease(handle);

   double adx = 0.0;
   if(UseCustomWilder)
      adx = CalcADX_Custom(sp.symbol, sp.diLen, sp.adxLen);
   else
      adx = iADXGet(sp.symbol,IndTimeframe,sp.adxLen);

   MqlRates rates[];
   CopyRates(sp.symbol,IndTimeframe,0,3,rates);
   double outsideThr = sp.outsidePips * sp.pipSize;
   bool prevOutUpper = rates[1].close > upper[1] + outsideThr;
   bool prevOutLower = rates[1].close < lower[1] - outsideThr;
   bool nowInUpper = rates[0].close < upper[0];
   bool nowInLower = rates[0].close > lower[0];
   bool adxPass = (adx < sp.adxMax);
   bool inSession = IsInAsianSession(sp.symbol);

   // check candle pattern (simple: require at least one enabled pattern)
   bool candleOK = CheckCandlePatterns(sp, rates);

   if(inSession && adxPass && candleOK && ((prevOutUpper && nowInUpper) || (prevOutLower && nowInLower)))
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//| Candle patterns check                                            |
//+------------------------------------------------------------------+
bool CheckCandlePatterns(const StratParams &sp, MqlRates rates[])
  {
   // rates[0] = current, [1] = prev, [2] = prev2
   // Implement Engulfing, Harami, Shooting Star, Morning/Evening star
   bool be = (rates[1].close > rates[1].open) && (rates[0].open > rates[0].close) && (rates[0].open >= rates[1].close) && (rates[1].open >= rates[0].close) && ((rates[0].open - rates[0].close) > (rates[1].close - rates[1].open));
   bool bh = (rates[1].close > rates[1].open) && (rates[0].open > rates[0].close) && (rates[0].open <= rates[1].close) && (rates[1].open <= rates[0].close) && ((rates[0].open - rates[0].close) < (rates[1].close - rates[1].open));
   bool st = (rates[1].open < rates[1].close) && (rates[0].open > rates[1].close) && ((rates[0].high - MathMax(rates[0].open,rates[0].close)) >= MathAbs(rates[0].open - rates[0].close)*3) && ((MathMin(rates[0].open,rates[0].close) - rates[0].low) <= MathAbs(rates[0].open - rates[0].close));
   bool ev = (rates[2].close > rates[2].open) && (MathMin(rates[1].open,rates[1].close) > rates[2].close) && (rates[0].open < MathMin(rates[1].open,rates[1].close)) && (rates[0].close < rates[0].open);
   bool buE = (rates[1].open > rates[1].close) && (rates[0].close > rates[0].open) && (rates[0].close >= rates[1].open) && (rates[1].close >= rates[0].open) && ((rates[0].close - rates[0].open) > (rates[1].open - rates[1].close));
   bool buH = (rates[1].open > rates[1].close) && (rates[0].close > rates[0].open) && (rates[0].close <= rates[1].open) && (rates[1].close <= rates[0].open) && ((rates[0].close - rates[0].open) < (rates[1].open - rates[1].close));
   bool mo = (rates[2].close < rates[2].open) && (MathMax(rates[1].open,rates[1].close) < rates[2].close) && (rates[0].open > MathMax(rates[1].open,rates[1].close)) && (rates[0].close > rates[0].open);

   bool bearPattern = (sp.useBE && be) || (sp.useBH && bh) || (sp.useST && st) || (sp.useEvening && ev);
   bool bullPattern = (sp.useBullE && buE) || (sp.useBullH && buH) || (sp.useMorning && mo);
   return (bearPattern || bullPattern);
  }

//+------------------------------------------------------------------+
//| TryEnterMean / Trend: compute lots, SL/TP and send orders        |
//+------------------------------------------------------------------+
void TryEnterMean(const StratParams &sp, int magic, double weight)
  {
   MqlRates rates[];
   if(CopyRates(sp.symbol,IndTimeframe,0,3,rates) < 3) return;
   // compute entry price (market)
   double entry = SymbolInfoDouble(sp.symbol,SYMBOL_ASK);
   // decide long/short based on prevOutLower/Upper
   int handle = iBands(sp.symbol,IndTimeframe,sp.bb_length,(int)sp.bb_mult,0,PRICE_CLOSE);
   double upper[], middle[], lower[];
   CopyBuffer(handle,0,0,3,upper);
   CopyBuffer(handle,1,0,3,middle);
   CopyBuffer(handle,2,0,3,lower);
   IndicatorRelease(handle);

   double outsideThr = sp.outsidePips * sp.pipSize;
   bool prevOutUpper = rates[1].close > upper[1] + outsideThr;
   bool prevOutLower = rates[1].close < lower[1] - outsideThr;
   bool nowInUpper = rates[0].close < upper[0];
   bool nowInLower = rates[0].close > lower[0];

   bool isShort = (prevOutUpper && nowInUpper);
   bool isLong  = (prevOutLower && nowInLower);
   if(!isShort && !isLong) return;

   // Compute SL
   double sl;
   if(isShort)
     {
      // SL per Pine logic
      if(sp.useST && IsShootingStar(sp.symbol)) sl = rates[0].high + sp.slBufferPips*sp.pipSize;
      else sl = (sp.useMotherHL ? rates[1].high + sp.slBufferPips*sp.pipSize : rates[0].high + sp.slBufferPips*sp.pipSize);
     }
   else
     {
      if(sp.useST && IsShootingStar(sp.symbol)) sl = rates[0].low - sp.slBufferPips*sp.pipSize;
      else sl = (sp.useMotherHL ? rates[1].low - sp.slBufferPips*sp.pipSize : rates[0].low - sp.slBufferPips*sp.pipSize);
     }

   double R = MathAbs(entry - sl);
   if(R <= SymbolInfoDouble(sp.symbol,SYMBOL_POINT)*2) { Print("R too small, skip"); return; }

   // TP2 fixed
   double tp2 = isShort ? (lower[0] - sp.bandPadPips*sp.pipSize) : (upper[0] + sp.bandPadPips*sp.pipSize);
   bool useSingleTP = MathAbs(tp2 - entry) < R;

   // compute Vi and risk cash
   double E = AccountInfoDouble(ACCOUNT_EQUITY);
   double Vi = weight * E;
   double riskPct = riskPctDefault/100.0; // input in percent
   double riskCash = Vi * riskPct;

   double riskA_cash = riskCash * riskSplitA;
   double riskB_cash = riskCash * (1.0 - riskSplitA);

   // compute cash_per_point_per_lot
   double cash_per_point = CashPerPointPerLot(sp.symbol);
   double Rpoints = R / SymbolInfoDouble(sp.symbol,SYMBOL_POINT);

   double lotsA = NormalizeLot(riskA_cash / (Rpoints * cash_per_point), sp.symbol);
   double lotsB = NormalizeLot(riskB_cash / (Rpoints * cash_per_point), sp.symbol);
   if(useSingleTP)
     {
      // only leg B
      if(lotsB < SymbolInfoDouble(sp.symbol,SYMBOL_VOLUME_MIN)) { Print("LotsB too small, skip"); return; }
      SendMarketOrder(sp.symbol, isLong? ORDER_TYPE_BUY:ORDER_TYPE_SELL, lotsB, sl, tp2, magic);
     }
   else
     {
      if(lotsA >= SymbolInfoDouble(sp.symbol,SYMBOL_VOLUME_MIN))
         SendMarketOrder(sp.symbol, isLong? ORDER_TYPE_BUY:ORDER_TYPE_SELL, lotsA, sl, isLong? entry+R:entry-R, magic);
      if(lotsB >= SymbolInfoDouble(sp.symbol,SYMBOL_VOLUME_MIN))
         SendMarketOrder(sp.symbol, isLong? ORDER_TYPE_BUY:ORDER_TYPE_SELL, lotsB, sl, tp2, magic);
     }

   PrintFormat("Entered Mean %s %s entry=%.5f SL=%.5f TP2=%.5f lotsA=%.2f lotsB=%.2f Vi=%.2f riskCash=%.2f",
               sp.symbol, isLong? "LONG":"SHORT", entry, sl, tp2, lotsA, lotsB, Vi, riskCash);
  }

void TryEnterTrend(const StratParams &sp, int magic, double weight)
  {
   // similar to mean but TP2 trailing (we open Leg A and Leg B market orders)
   MqlRates rates[];
   if(CopyRates(sp.symbol,IndTimeframe,0,10,rates) < sp.lookbackSL+3) return;
   int handle = iBands(sp.symbol,IndTimeframe,sp.bb_length,(int)sp.bb_mult,0,PRICE_CLOSE);
   double upper[], middle[], lower[];
   CopyBuffer(handle,0,0,3,upper);
   CopyBuffer(handle,1,0,3,middle);
   CopyBuffer(handle,2,0,3,lower);
   IndicatorRelease(handle);

   double entry = SymbolInfoDouble(sp.symbol,SYMBOL_ASK);
   // decide direction based on break vs prevOut
   double outsideThr = sp.outsidePips * sp.pipSize;
   bool prevOutUpper = rates[1].close > upper[1] + outsideThr;
   bool prevOutLower = rates[1].close < lower[1] - outsideThr;
   bool upperPrev = upper[1];
   bool lowerPrev = lower[1];
   bool longBreakBandHL = (rates[0].high > upperPrev);
   bool longBreakCloseHL = (rates[0].close > upperPrev) && (rates[0].high > rates[1].high);
   bool shortBreakBandHL = (rates[0].low < lowerPrev);
   bool shortBreakCloseHL = (rates[0].close < lowerPrev) && (rates[0].low < rates[1].low);
   bool longBreak = (sp.breakMode==0) ? longBreakBandHL : longBreakCloseHL;
   bool shortBreak = (sp.breakMode==0) ? shortBreakBandHL : shortBreakCloseHL;

   bool isLong = (prevOutLower && longBreak);
   bool isShort = (prevOutUpper && shortBreak);
   if(!isLong && !isShort) return;

   // SL as nearest HL (lookback)
   double recentLowPrev = ArrayMinimumLow(sp.symbol, sp.lookbackSL) ;
   double recentHighPrev = ArrayMaximumHigh(sp.symbol, sp.lookbackSL);
   double sl = isLong ? (recentLowPrev - sp.slBufferPips*sp.pipSize) : (recentHighPrev + sp.slBufferPips*sp.pipSize);
   double R = MathAbs(entry - sl);
   if(R <= SymbolInfoDouble(sp.symbol,SYMBOL_POINT)*2) return;

   double tp1 = isLong? entry + R : entry - R;
   double tp2_stop = isLong? (lower[0] - sp.bandPadPips*sp.pipSize) : (upper[0] + sp.bandPadPips*sp.pipSize);

   double E = AccountInfoDouble(ACCOUNT_EQUITY);
   double Vi = weight * E;
   double riskPct = riskPctDefault/100.0;
   double riskCash = Vi * riskPct;
   double riskA_cash = riskCash * riskSplitA;
   double riskB_cash = riskCash * (1.0 - riskSplitA);
   double cash_per_point = CashPerPointPerLot(sp.symbol);
   double Rpoints = R / SymbolInfoDouble(sp.symbol,SYMBOL_POINT);
   double lotsA = NormalizeLot(riskA_cash / (Rpoints * cash_per_point), sp.symbol);
   double lotsB = NormalizeLot(riskB_cash / (Rpoints * cash_per_point), sp.symbol);

   // Place both legs if possible
   if(lotsA >= SymbolInfoDouble(sp.symbol,SYMBOL_VOLUME_MIN))
     SendMarketOrder(sp.symbol, isLong? ORDER_TYPE_BUY:ORDER_TYPE_SELL, lotsA, sl, tp1, magic);
   if(lotsB >= SymbolInfoDouble(sp.symbol,SYMBOL_VOLUME_MIN))
     SendMarketOrder(sp.symbol, isLong? ORDER_TYPE_BUY:ORDER_TYPE_SELL, lotsB, sl, tp2_stop, magic);

   PrintFormat("Entered Trend %s %s entry=%.5f SL=%.5f TP1=%.5f LegB_stop=%.5f lotsA=%.2f lotsB=%.2f Vi=%.2f",
               sp.symbol, isLong? "LONG":"SHORT", entry, sl, tp1, tp2_stop, lotsA, lotsB, Vi);
  }

//+------------------------------------------------------------------+
//| Send Market Order wrapper                                         |
//+------------------------------------------------------------------+
bool SendMarketOrder(string symbol, ENUM_ORDER_TYPE type, double volume, double sl, double tp, int magic)
  {
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);

   request.action = TRADE_ACTION_DEAL;
   request.symbol = symbol;
   request.volume = volume;
   request.type = type;
   request.price = (type==ORDER_TYPE_BUY) ? SymbolInfoDouble(symbol,SYMBOL_ASK) : SymbolInfoDouble(symbol,SYMBOL_BID);
   request.deviation = (ulong)MaxSlippagePoints;
   request.type_filling = ORDER_FILLING_FOK;
   request.type_time = ORDER_TIME_GTC;
   request.magic = magic;
   request.sl = NormalizePrice(symbol, sl);
   request.tp = NormalizePrice(symbol, tp);

   if(SymbolInfoDouble(symbol,SYMBOL_SPREAD) > MinSpreadPoints) { PrintFormat("Spread too high for %s, skip", symbol); return false; }

   if(!OrderSend(request,result))
     {
      PrintFormat("OrderSend failed: %s", result.comment);
      return false;
     }
   else
     {
      PrintFormat("OrderSend success ticket=%d comment=%s", (int)result.order, result.comment);
      return true;
     }
  }

//+------------------------------------------------------------------+
//| Utility: Normalize price to digits                                |
//+------------------------------------------------------------------+
double NormalizePrice(string symbol, double price)
  {
   int digits = (int)SymbolInfoInteger(symbol,SYMBOL_DIGITS);
   return NormalizeDouble(price, digits);
  }

//+------------------------------------------------------------------+
//| Utility: Normalize lot to step/min                                |
//+------------------------------------------------------------------+
double NormalizeLot(double lots, string symbol)
  {
   double minlot = SymbolInfoDouble(symbol,SYMBOL_VOLUME_MIN);
   double lotstep = SymbolInfoDouble(symbol,SYMBOL_VOLUME_STEP);
   if(lots < minlot) return 0.0;
   double n = MathFloor((lots - minlot)/lotstep + 0.0000001);
   double res = minlot + n * lotstep;
   res = MathMax(res, minlot);
   return NormalizeDouble(res,2);
  }

//+------------------------------------------------------------------+
//| Count open setups (distinct magic numbers)                        |
//+------------------------------------------------------------------+
int CountOpenSetups()
  {
   int total=0;
   for(int i=OrdersTotal()-1;i>=0;i--)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
        {
         int mg = (int)OrderGetInteger(ORDER_MAGIC);
         if(mg==MAGIC_Trend_XAU || mg==MAGIC_Mean_XAU || mg==MAGIC_Trend_UJ || mg==MAGIC_Mean_UJ || mg==MAGIC_Mean_AUDJ) total++;
        }
     }
   return total;
  }
//+------------------------------------------------------------------+
//| Check if symbol has open setup (by magic mapping)                 |
//+------------------------------------------------------------------+
bool HasOpenSetupForSymbol(string symbol)
  {
   for(int i=OrdersTotal()-1;i>=0;i--)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
        {
         if(OrderGetString(ORDER_SYMBOL)==symbol)
           {
            int mg = (int)OrderGetInteger(ORDER_MAGIC);
            if(mg==MAGIC_Trend_XAU || mg==MAGIC_Mean_XAU || mg==MAGIC_Trend_UJ || mg==MAGIC_Mean_UJ || mg==MAGIC_Mean_AUDJ) return true;
           }
        }
     }
   return false;
  }

//+------------------------------------------------------------------+
//| Check session: Asian UTC 00:00 - 09:00                            |
//+------------------------------------------------------------------+
bool IsInAsianSession(string symbol)
  {
   datetime serverTime = TimeCurrent() - ServerUTCOffsetHours*3600;
   MqlDateTime dt; TimeToStruct(serverTime,dt);
   int utcHour = dt.hour;
   return (utcHour >= 0 && utcHour < 9);
  }

//+------------------------------------------------------------------+
//| Cash per point per lot estimation                                 |
//+------------------------------------------------------------------+
double CashPerPointPerLot(string symbol)
  {
   double tick_value = SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_SIZE);
   double point = SymbolInfoDouble(symbol,SYMBOL_POINT);
   if(tick_size==0) tick_size = point;
   if(tick_value==0)
     {
      // fallback: assume for FX 1 lot = 100,000 base => 1 pip ~ 10 USD for EURUSD style; rough fallback:
      return 10.0;
     }
   double cash_per_point = (tick_value / tick_size) * point;
   return MathAbs(cash_per_point);
  }

//+------------------------------------------------------------------+
//| Custom ADX (Wilder) approximate implementation                   |
//| If shift=0 returns current, shift=1 returns previous             |
//+------------------------------------------------------------------+
double CalcADX_Custom(string symbol, int diLen, int adxLen, int shift=0)
  {
   int barsNeeded = MathMax(diLen,adxLen) + 10;
   MqlRates rates[];
   if(CopyRates(symbol,IndTimeframe,shift,barsNeeded,rates) < barsNeeded) return 100.0;
   // compute DM and TR arrays
   int n = ArraySize(rates);
   // build plusDM, minusDM, tr
   double plusDM[], minusDM[], tr[];
   ArrayResize(plusDM,n); ArrayResize(minusDM,n); ArrayResize(tr,n);
   for(int i=1;i<n;i++)
     {
      double upMove = rates[i-1].high - rates[i].high;
      double downMove = rates[i].low - rates[i-1].low;
      // note: rates index reversed due CopyRates shift; we approximate using high differences
      double up = rates[i-1].high - rates[i].high;
      double down = rates[i].low - rates[i-1].low;
      plusDM[i] = (up > 0 && up > down) ? up : 0.0;
      minusDM[i]= (down > 0 && down > up) ? down : 0.0;
      double trueRange = MathMax(rates[i-1].high - rates[i-1].low, MathMax(MathAbs(rates[i-1].high - rates[i].close), MathAbs(rates[i-1].low - rates[i].close)));
      tr[i] = trueRange;
     }
   // Wilder RMA for ATR and DM
   double atr=0, plusR=0, minusR=0;
   // seed with simple sum of first diLen values
   double sumTR=0, sumPlus=0, sumMinus=0;
   int start = n-1;
   for(int i=1;i<=diLen && (start-i)>=0;i++)
     { sumTR += tr[start-i+1]; sumPlus += plusDM[start-i+1]; sumMinus += minusDM[start-i+1]; }
   atr = sumTR/diLen;
   plusR = sumPlus/diLen;
   minusR = sumMinus/diLen;
   // rma forward to get to latest
   for(int i=start-diLen+2;i<=start;i++)
     {
      if(i<1 || i>=n) continue;
      atr = (atr*(diLen-1) + tr[i]) / diLen;
      plusR = (plusR*(diLen-1) + plusDM[i]) / diLen;
      minusR= (minusR*(diLen-1) + minusDM[i]) / diLen;
     }
   double plusDI = atr>0 ? 100.0 * plusR / atr : 0.0;
   double minusDI = atr>0 ? 100.0 * minusR / atr : 0.0;
   double dx = (plusDI + minusDI) > 0 ? 100.0 * MathAbs(plusDI - minusDI) / (plusDI + minusDI) : 0.0;
   // now RMA dx for adxLen periods: approximate by smoothing dx with rma seed equal dx
   double adx = dx;
   // Ideally we'd iterate historic dx values â€” for prototype return dx as adx approximation
   return adx;
  }

//+------------------------------------------------------------------+
//| Small wrappers for using built-in iADX if chosen                 |
//+------------------------------------------------------------------+
double iADXGet(string symbol, ENUM_TIMEFRAMES tf, int period)
  {
   int handle = iADX(symbol,tf,period);
   double buf[];
   if(CopyBuffer(handle,0,0,1,buf)<=0) { IndicatorRelease(handle); return 0.0; }
   double val = buf[0];
   IndicatorRelease(handle);
   return val;
  }
double iADXGetPrevious(string symbol, ENUM_TIMEFRAMES tf, int period)
  {
   int handle = iADX(symbol,tf,period);
   double buf[];
   if(CopyBuffer(handle,0,1,2,buf)<=0) { IndicatorRelease(handle); return 0.0; }
   double val = buf[1];
   IndicatorRelease(handle);
   return val;
  }

//+------------------------------------------------------------------+
//| Utility: find recent low/high using CopyRates                     |
//+------------------------------------------------------------------+
double ArrayMinimumLow(string symbol, int lookback)
  {
   MqlRates rates[];
   if(CopyRates(symbol,IndTimeframe,1,lookback+1,rates) <=0) return SymbolInfoDouble(symbol,SYMBOL_BID);
   double minv = rates[0].low;
   for(int i=0;i<ArraySize(rates);i++) minv = MathMin(minv, rates[i].low);
   return minv;
  }
double ArrayMaximumHigh(string symbol, int lookback)
  {
   MqlRates rates[];
   if(CopyRates(symbol,IndTimeframe,1,lookback+1,rates) <=0) return SymbolInfoDouble(symbol,SYMBOL_ASK);
   double maxv = rates[0].high;
   for(int i=0;i<ArraySize(rates);i++) maxv = MathMax(maxv, rates[i].high);
   return maxv;
  }

//+------------------------------------------------------------------+
//| Candle check helpers                                              |
//+------------------------------------------------------------------+
bool IsShootingStar(string symbol)
  {
   MqlRates r[];
   if(CopyRates(symbol,IndTimeframe,0,2,r) < 2) return false;
   // use current bar only
   MqlRates cur; CopyRates(symbol,IndTimeframe,0,1,cur);
   // simplified detection
   double body = MathAbs(cur[0].open - cur[0].close);
   if(body==0) return false;
   if((cur[0].high - MathMax(cur[0].open,cur[0].close)) >= body*3 && (MathMin(cur[0].open,cur[0].close) - cur[0].low) <= body) return true;
   return false;
  }

//+------------------------------------------------------------------+
//| Helper: check now in band from above/below                        |
//+------------------------------------------------------------------+
bool nowInBandFromAbove(string symbol, double upper)
  {
   MqlRates r[]; if(CopyRates(symbol,IndTimeframe,0,2,r)<2) return false;
   return (r[0].close < upper);
  }
bool nowInBandFromBelow(string symbol, double lower)
  {
   MqlRates r[]; if(CopyRates(symbol,IndTimeframe,0,2,r)<2) return false;
   return (r[0].close > lower);
  }
//+------------------------------------------------------------------+
